#!/usr/bin/python

#
# dispatch-conf -- Integrate modified configs, post-emerge
#
#  Jeremy Wohl (http://igmus.org)
#  $Id: dispatch-conf,v 1.8 2003/01/07 19:21:57 jeremyw Exp $
#
# TODO
#  dialog menus
#  backup over-written files?
#

import os, sys, re, commands
import portage

FIND_EXTANT_CONFIGS  = "find %s -iname '._cfg????_*'"
DIFF_CONTENTS        = 'diff -Nau %s %s'
DIFF_CVS_INTERP      = 'diff -Nau %s %s | grep "^[+-][^+-]" | grep -v "# .Header:.*"'
DIFF_WSCOMMENTS      = 'diff -Nau %s %s | grep "^[+-][^+-]" | grep -v "^[-+]#" | grep -v "^[-+][:space:]*$"'
MERGE                = 'sdiff --suppress-common-lines --output=%s %s %s'

MANDATORY_OPTS  = [ 'diff', 'pager', 'replace-cvs', 'replace-wscomments' ]

def main ():
    confs = []
    count = 0

    options = read_config ()

    #
    # Build list of extant configs
    #
    
    for path in portage.settings ['CONFIG_PROTECT'].split ():
        if not os.path.exists (path):
            continue
        
        confs += massage (os.popen (FIND_EXTANT_CONFIGS % (path,)).readlines ())

    #
    # Remove new configs identical to current
    #                  and
    # Auto-replace configs a) whose differences are simply CVS interpolations,
    #                  or  b) whose differences are simply ws or comments,
    #                  or  c) in paths now unprotected by CONFIG_PROTECT_MASK,
    #
    
    def f (conf):
        same_file = len(commands.getoutput (DIFF_CONTENTS   % (conf ['current'], conf ['new']))) == 0
        same_cvs  = len(commands.getoutput (DIFF_CVS_INTERP % (conf ['current'], conf ['new']))) == 0
        same_wsc  = len(commands.getoutput (DIFF_WSCOMMENTS % (conf ['current'], conf ['new']))) == 0

        # Do options permit?
        same_cvs  = same_cvs and options ['replace-cvs'] == 'yes'
        same_wsc  = same_wsc and options ['replace-wscomments'] == 'yes'

        if same_file:
            os.unlink (conf ['new'])
            return False
        elif same_cvs or same_wsc or conf ['dir'] in portage.settings ['CONFIG_PROTECT_MASK'].split ():
            os.rename (conf ['new'], conf ['current'])
            return False
        else:
            return True

    confs = filter (f, confs)

    #
    # Interactively process remaining
    #
    
    for conf in confs:
        count = count + 1

        while 1:
            os.system ((options ['diff'] + '| %s') % (conf ['current'], conf ['new'], options ['pager']))

            print
            print '>> (%i of %i) -- %s' % (count, len(confs), conf ['current'])
            print '>> q quit, h help, n skip, f fuse/merge, k kill new, s supercede w/new',

            c = getch ()
                
            if c == 'q':
                sys.exit (0)
            if c == 'h':
                do_help ()
                continue
            elif c == 'n':
                break
            elif c == 'f':
                merged = '/tmp/dispatch-conf.merged.%i' % (os.getpid (),)
                print
                os.system (MERGE % (merged, conf ['current'], conf ['new']))
                os.rename (merged, conf ['new'])
                continue
            elif c == 'k':
                os.remove (conf ['new'])
                break
            elif c == 's':
                os.rename (conf ['new'], conf ['current'])
                break
            else:
                continue


def massage (newconfigs):
    """Sort, rstrip, remove old versions, break into triad hash.

    Triad is dictionary of current (/etc/make.conf), new (/etc/._cfg0003_make.conf)
    and dir (/etc).

    We keep ._cfg0002_conf over ._cfg0001_conf and ._cfg0000_conf.
    """
    h = {}

    newconfigs.sort ()

    for nconf in newconfigs:
        nconf = nconf.rstrip ()
        conf  = re.sub (r'\._cfg\d+_', '', nconf)
        dir   = re.match (r'^(.+)/', nconf).group (1)
        h [conf] = { 'current' : conf, 'dir' : dir, 'new' : nconf }

    configs = h.values ()
    configs.sort (lambda a, b: cmp(a ['current'], b ['current']))

    return configs


def do_help ():
    print; print

    print '  q -- quit'
    print '  h -- this screen'
    print '  n -- next/skip to next config, leave all intact'
    print '  f -- interactively fuse/merge current and new configs'
    print '  k -- kill/remove new config and continue'
    print '  s -- supercede current config with new and continue'

    print; print 'press any key to return to diff...',
    
    getch ()
    

def read_config ():
    try:
        opts = portage.getconfig ('/etc/dispatch-conf.conf')
    except:
        opts = None

    if not opts:
        print >> sys.stderr, 'dispatch-conf: Error reading /etc/dispatch-conf.conf; fatal'
        sys.exit (1)

    for key in MANDATORY_OPTS:
        if not opts.has_key (key):
            print >> sys.stderr, 'dispatch-conf: Missing option "%s" in /etc/dispatch-conf.conf; fatal' % (key,)

    return opts
    

def getch ():
    # from ASPN - Danny Yoo
    #
    import sys, tty, termios
    
    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)
    try:
        tty.setraw(sys.stdin.fileno())
        ch = sys.stdin.read(1)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
    return ch

        
main ()
